# Графічний інтерфейс користувача

Якщо в налаштуваннях Pixeler в файлі `pixeler/setup/graphics_setup.h` додано визначення 

```cpp
#define GRAPHICS_ENABLED
```
в клас контексту буде додано підтримку виводу графіки на дисплей. 
<br>
Налаштування дисплею також знаходяться в цьому файлі.
<br>

Формування графічного інтерфейсу користувача в Pixeler відбувається в межах макета, який потрібно зформувати в класі контексту.
Один і той же контекст може мати безліч макетів GUI. Головним завданням в такому випадку буде коректне налаштування перемикання машини станів контексту.
Машина станів необхідна для того, щоб контекст помилково не спробував взаємодіяти з видаленим віджетом через висячий вказівник. 

## Віджети

`Віджет` це найменший компонент графічного інтерфейсу користувача, що має стандартні зовнішній вигляд та поведінку.
<br>

На даний момент в Pixeler реалізовано наступні віджети:

* `EmptyLayout` - віджет, який є простою панеллю для компонування інших віджетів.
* `Label` - використовується для виводу тексту.
* `TextBox` - успадкований від Label та слугує полем для вводу тексту або пароля.
* `ToggleSwitch` - віджет для відображення стану, який може бути описаний як “увімкнено/вимкнено”.
* `Image` - для формування і виводу зображень на дисплей із масивів, що містять інформацію про пікселі зображення.
* `Spinbox` - елемент, який дозволяє зациклювати діапазон чисел.
* `Фіксоване та динамічне меню` - обидва слугують для візуалізації списків, але мають принципові відмінності у функціонуванні. 

    `Фіксоване(FixedMenu)` формується відразу повністю у пам'яті, незалежно від його розміру. Пункти меню можуть бути додані та видалені по одному. 

    `Динамічне(DynamicMenu)` - створюється частинами, в процесі прокручування списку таким чином, щоб мінімізувати використання оперативної пам'яті мікроконтролера. Кожна наступна порція даних замінює попередню. Контроль завантаження даних повинен організувати розробник. Динамічне меню пропонує тільки інтерфейс для їх зручного додавання та гарантує виклик обробників прокрутки списку.

* `MenuItem` - базовий елемент списка меню, що містить текст елемета та може містити іконку. Окрім базового елемента списку, можна використовувати інші, більш просунуті елементи, які успадковані від нього.

    `ToggleItem` - елемент меню з ToggleSwitch.

    `SpinItem` - елемент меню з SpinBox.

    `ComboItem` - елемент меню з прокручуваним списком текстових значень.

* `Scrollbar` - віджет, який дозволяє візуалізувати прогрес прокручування списку.
* `Progressbar` - віджет, який може бути використаний для відображення прогресу виконання задачі.
* `Keyboard` та `KeyboardRow` - віджети для формування розкладок віртуальної клавіатури.

## Контейнери віджетів

`Контейнер віджетів` це спеціальний тип віджетів, який може зберігати в собі інші віджети та викликати малювання у них.
Контейнер віджетів може виконувати пошук та видалення віджета по його унікальному ідентифікатору.
Також контейнер слідкує за унікальністю ідентифікаторів віджетів, які додаються до нього.

Контейнер віджетів також може бути доданий до контейнера віджетів.

## Клонування віджетів

Для зменшення обсягу коду в контексті є доцільним використовувати механізм клонування віджетів, 
замість створення нового віджета та встановлення його параметрів вручну.

```cpp
    // Створюємо новий віджет та налаштовуємо його
    Image* _img_back_normal = new Image(1);
    _img_back_normal->setWidth(IMG_W);
    _img_back_normal->setHeight(IMG_H);
    _img_back_normal->setSrc(BTN_BACK_NORMAL);
    _img_back_normal->setBackColor(COLOR_MAIN_BACK);
    _img_back_normal->setTransparency(true);

    Label* lbl_online = new Label(1);
    item_online->setLbl(lbl_online);
    lbl_online->setAlign(IWidget::ALIGN_CENTER);
    lbl_online->setGravity(IWidget::GRAVITY_CENTER);
    lbl_online->setTextColor(COLOR_BLACK);
    lbl_online->setBackImg(_img_back_normal->clone(1)); // Тут клонуємо Image
    lbl_online->setText(STR_MULTI_GAME);
    // ...

    Label* lbl_pref = lbl_online->clone(1);           // Тут клонуємо Label
    item_pref->setLbl(lbl_pref);
    lbl_pref->setBackImg(_img_back_normal->clone(1)); // Тут клонуємо Image
    lbl_pref->setText(STR_PREFERENCES);               // Міняємо тільки відмінні параметри
```

Клонування контейнера віджетів також викличе клонування усіх вкладених до нього віджетів.
Тобто буде створено його глибоку копію, яка ніяк не пов'язана з оригіналом.

## Позиціонування віджетів

Усі віджети в макеті позиціонуються відносно свого батьківського контейнера + 1 піксель для малювання рамки контейнера.
Тобто, якщо контейнер має координати `[10, 5]`, а вкладений віджет `[5, 5]`, 
то на дисплей вкладений віджет буде виведено в координатах `[16, 11]`.
Тому що `[10 + 5 + 1, 5 + 5 + 1]`.

Система координат починається у верхньому лівом куті екрана. 
Тобто координатна сітка перевернута вертикально в порівнянні з класичною, яка всім знайома з уроків алгебри.

## Правила малювання віджетів

* Кожен віджет має доступ до графічного драйвера Pixeler та може самостійно малювати себе на Canvas відповідно до власних параметрів.
* Кожен віджет контролює зміну свого стану та, якщо його не було оновлено в поточному кадрі, пропускає чергу свого малювання.
    Частковим виключенням з цього правила є контейнер віджетів. Якщо його стан не було оновлено, він пропускає власне перемальовування, але викликає по черзі малювання вкладених до нього віджетів. 
    Вкладені віджети будуть перемальовані відповідно до вищезазначених правил.
* Якщо було оновлено стан контейнера віджетів, до всіх вкладених віджетів буде застосовано примусове перемальовування.
* Малювання віджетів викликаєтсья в тому порядку, в якому вони були додані до свого контейнера.
* Усі віджети малюються виключно в буфер Canvas-у, та не можуть малювати себе безпосередньо на дисплей.


## Макет графічного інтерфейсу

Теоретично будь-який віджет можна вивести на Canvas без прив'язки до контексту чи контейнера.
Але в такому випадку користувач повинен самостійно контролювати звільнення пам'яті, позиціонування та перемальовування віджетів і тд.
Тож такий спосіб створення графічного інтерфейсу користувача не рекомендується.
Рекомендованим варіантом є саме використання вбудованих можливостей контексту для малювання макету на дисплей.
<br>

Для того щоб встановити або змінити макет для контексту, необхідно в його коді викликати метод 

```cpp
    setLayout(layout);
```

Де `layout` це будь-який віджет-контейнер.

Розміри базового контейнера віджетів рекомендується налаштовувати для відображення на повний екран.
Фактично він буде використовуватися, як основне тло макету.
<br>

Нижче наведено приклад початкової ініціалізації, та встановлення макету в конструкторі контексту.
```cpp
    MenuContext::MenuContext()
    {
    // Створюємо з допомогою шаблонізатора новий порожній макет,
    // який буде каркасом для GUI
    EmptyLayout* layout = WidgetCreator::getEmptyLayout();

    // Встановлюємо цей макет для поточного контексту
    setLayout(layout);

    // Створюємо віджет меню з унікальним ідентифікатором,
    // по якому зможемо його знайти, за потреби, на макеті
    FixedMenu *menu = new FixedMenu(ID_MENU);
    // Додаємо цей віджет до раніше створеного макету
    layout->addWidget(menu);

    // Налаштовуємо зовнішній вигляд меню, 
    // та додаємо елементи списку, якщо потрібно
    //...
    }
```

Макет можна змінювати на інший протягом усього часу інсування контексту в залежності від його поточного стану. 

## Контейнери віджетів та асинхронність

Контейнери віджетів в Pixeler не підтримують асинхронність. Розробник повинен самостійно реалізувати коректну чергу малювання GUI, щоб можливі зміни через зворотні виклики не конфліктували з нею. 
Єдиним потокобезпечним методом в GUI Pixeler є `setLayout`.
