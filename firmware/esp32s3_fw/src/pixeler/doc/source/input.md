# Користувацький ввід

Майже будь-який пристрій, для якого планується використання Pixeler в прошивці, потребує використання кнопок.
Це може бути кишеньковий пристрій по типу ігрової консолі чи mp3-програвача, пульт або панель керування тощо.
<br>
<br>
Pixeler підтримує зчитування стану кнопок з трьох джерел.
 * GPIO мікроконтролера ESP.
 * Сенсорні датчики ESP.
 * Зчитування стану кнопок з допоміжного МК по шині I2C.

Перші два варіанти можуть бути використані одночасно, при цьому жоден із них не може комбінуватися разом з третім варіантом.

## Реєстрація кнопок

Усі віртуальні кнопки реєструються та налаштовуються для Pixeler в файлі `pixeler/setup/input_setup.h`.
Також в цьому файлі вмикається або вимикається підтримка зчитування стану кнопок по шині I2C з допоміжного МК.
<br>
<br>
Якщо в прошивці планується використання тільки кнопок, що приєднуються безпосердньо до ESP,
тоді в перечислення необхідно додати значення у вигляді
<br>
`[віртуальне_ім'я_кнопки = пін_до_якого_приєднана]`

```cpp
  enum BtnID : uint8_t
  {
    BTN_OK = 10,
    BTN_LEFT = 12,
    BTN_RIGHT = 13,
  };
```

Після цього, в макросі для створення мапи додати пари ключ-значення для кожної кнопки. 
Де ключем є віртуальне ім'я кнопки, а значенням - об'єкт кнопки.
В конструктор об'єкта кнопки необхідно першим параметром передати віртуальне ім'я кнопки, через яке кнопка прив'яжеться до відповідного піна.
Другим параметром передається булеве значення, яке вказує чи є кнопка сенсорною.

```cpp
#define BUTTONS_TMPL                         \
  {                                          \
      {BTN_OK, Button(BTN_OK, false)},       \
      {BTN_LEFT, Button(BTN_LEFT, false)},   \
      {BTN_RIGHT, Button(BTN_RIGHT, true)},  \
  }
```

Окрім того, визначення `EXT_INPUT` повинне бути обов'язково закоментоване.
Інакше Pixeler вважатиме, що стан вводу потрібно зчитувати саме по шині I2C.

## Зчитування вводу по I2C

Варіант зчитування вводу з допоміжного МК може не підійти для новачків,
тому що його значно складніше налаштувати.
<br>

Спочатку потрібно самостійно запрограмувати будь-який інший мікроконтролер,
таким чином, аби він працював в режимі веденого на шині I2C, та міг коректно оброблювати і реагувати на команди.
<br>

З'єднати ведучий ESP та ведений МК відповідно до правил шини I2C.
<br>

Налаштувати піни I2C та адресу веденого пристрою в файлах `pixeler/setup/i2c_setup.h` та `pixeler/setup/coprocessor_setup.h`.

::: {note}
В прикладах прошивок може використовуватися різний набір команд для допоміжного МК.
Але для коректної роботи з кнопками важливі тільки три. 
Інші команди використовуються для вирішення інших задач.
:::

```cpp
  typedef enum : uint8_t
  {
    CCPU_CMD_ENABLE = 0,        // Необов'язкова. Увімкнення пристрою.
    CCPU_CMD_DISABLE,           // Необов'язкова. Вимкнення пристрою.
    CCPU_CMD_PIN_ON,            // Необов'язкова. Встановити пін в 1.
    CCPU_CMD_PIN_OFF,           // Необов'язкова. Встановити пін в 0.
    //
    CCPU_CMD_GET_BTNS_STATE,    // Обов'язкова. Повернути стан кнопок.
    CCPU_CMD_BTN_OFF,           // Обов'язкова. Вимкнути кнопку.
    CCPU_CMD_BTN_ON,            // Обов'язкова. Увімкнути кнопку.
  } CoprocessorCMD_t;
```
<br>
<br>
Усі команди ведучий ESP надсилає в межах стандартного протоколу I2C, де перший байт являється номером команди.
<br>

`Команда увімкнення кнопки` повідомляє допоміжному МК, що надалі кнопка за вказаною позицією буде використовуватися, та повинна бути коректно налаштована.
<br>

`Команда вимкнення кнопки` очікує, що допоміжний МК деініціалізує пін кнопки та переведе його у високоімпедансний вхід. 
Або відключить сенсорний датчик, що прив'язаний до цієї кнопки, для збереження енергії, тощо.
<br>

`Команда запиту стану кнопок` очікує що допоміжний МК надасть інформацію про стан *усіх* кнопок, запаковану в біти.
Де кожен біт, що зв'язаний з реальною кнопкою йде в тому порядку, в якому кнопки реєструються в налаштуваннях основного МК.
<br>

Для прикладу, перечислення кнопок в налаштуванняях Pixeler має наступний вигляд:

```cpp
  enum BtnID : uint8_t
  {
    BTN_PTT = 0,
    BTN_OK,
    BTN_BACK,
    BTN_LEFT,
    BTN_RIGHT,
    BTN_UP,
    BTN_DOWN,
  };
```
У визначенні `#define EXT_INPUT_B_NUM 1` встановлено 1, тому що це значення вказує скільки байт повинен зчитувати по I2C основний МК,
коли запитує стан кнопок. В один байт можна вмістити стан до 8 кнопок. Якщо кількість кнопок не є кратною кількості біт,
вільні біти можна не скидати. Їх буде проігноровано в Pixeler в будь-якому випадку.
<br> 

Припустимо, що допоміжний МК повернув поточний стан кнопок у вигляді значення `0b1000 0000`. 
Для Pixeler це означатиме, що зараз натиснута кнопка `BTN_PTT`, а всі інші неактивні.
<br> 

Якщо отримано `0b0100 0010` - Знаходяться в активному стані тільки кнопки `BTN_OK` та `BTN_UP`.
<br> 

Якщо отримано `0b0000 0001` - Усі зареєстровані кнопки знаходяться в неактивному стані.
Значення біт на позиціях більших, ніж кількість кнопок, ігноруються.
<br> 
<br> 

Зв'язування об'єктів кнопок з їх ідентифікаторами відбуваєтсья так само, як і для пінів на ESP. 
Єдина відмінність в логіці такого зв'язування в тому, що булеве значення, яке вказує на тип кнопки буде проігнороване.

## Обробка вводу

В межах контексту стан кнопок перевіряється однаково, незалежно від методу його зчитування.
<br>

Стан кнопок є актуальним тільки в методі `update`, та не повинен перевірятися в методі `loop`.
Під час завантаження контексту, стан усіх кнопок скидається до неактивного.

```cpp
void MenuContext::update()
{
  // Перевіряємо чи кнопка утримується довгий час
  if (_input.isPressed(BtnID::BTN_BACK))
  {
    _input.lock(BtnID::BTN_BACK, PRESS_LOCK);
    // ...
  }
  // Перевіряємо чи кнопка просто натиснута
  else if (_input.isHolded(BtnID::BTN_UP))
  {
    _input.lock(BtnID::BTN_UP, HOLD_LOCK);
    // ...
  }
  // Перевіряємо чи кнопка була натиснута та відпущена
  else if (_input.isReleased(BtnID::BTN_DOWN))
  {
    _input.lock(BtnID::BTN_DOWN, CLICK_LOCK);
    // ...
  }
}
```

## Блокування кнопки

Зазвичай, в бібліотеках обробки кнопок для мікроконтролерів, після зчитування стану, кнопка блокується на фіксоване значення часу.
Це необхідно задля уникнення фантомних спрацювань, в момент коли користувач пристрою не встиг міцно притиснути кнопку.
В Pixeler час блокування є динамічним, та має додаткове призначення.
З його допомогою налашовується затримка до наступного спрацювання кнопки.
Таким чином можна коригувати швидкість прокрутки списків. Або переміщення фокусу по клавіатурі.
Також, особливо корисним є блокування кнопки на тривалий час, після спрацювання довгого утримання. 
Коли користувач пристрою довго утримує кнопку, після зміни контексту він може не втигнути відпустити кнопку в короткий проміжок часу.
Тож кнопка почне оброблюватися вже в новому контексті неочікувано для користувача.
<br>
В той же час, після звичайних натискань довга затримка не потрібна, тому що це заважатиме користувачу часто натискати кнопку.
<br>

::: {warning}
Стан `isPressed` завжди повинен перевірятися до `isHolded` для однієї кнопки! 
Тому що `isPressed` включає в себе `isHolded`, але навпаки ні.
Якщо перевіряти `isHolded` першим, то умова `isPressed` ніколи не виконається.
::: 

Блокування кнопки не є обов'язким механізмом. Наприклад, в іграх немає сенсу блокувати кнопки переміщення персонажа, якщо він рухається не по клітинках.
<br>
Також не обов'язково оброблювати стан лише однієї кнопки за кадр. Можна оброблювати одночасно натискання декількох чи взагалі усіх кнопок. Що може бути корисним для створення комбінацій кнопок, якщо в пристрої доступна лише обмежена кількість пінів.

## Вимкнення кнопки

В деяких випадках може бути потрібно відключити частину кнопок. Наприклад, якщо кишеньковий пристрій блокується, можна вимкнути усі кнопки окрім однієї, яка відповідатиме за розблокування, замість того, щоб додавати окремі умови для обробки стану блокування. Окрім того, деініціалізація сенсорних панелей дає незначне зменшення споживання струму мікроконтролером. 

```cpp
// Вимкнути кнопку
_input.disableBtn(BtnID::BTN_BACK);

// Увімкнути кнопку
_input.enableBtn(BtnID::BTN_BACK);

```
::: {important}
Якщо стан кнопок зчитується з допоможіного МК, рекомендується також реалізувати команду вимкнення кнопки на ньому.
Хоча програмно Pixeler самостійно оброблює стан кнопки [увімкнена/вимкнена], може бути корисним відключати кнопку також на рівні заліза.
::: 

