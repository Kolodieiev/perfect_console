# Карта пам'яті

Для роботи з картою пам'яті по шині SPI в Pixeler реалізовано власний файловий менеджер, 
який інтегровано до кожної бібліотеки та всіх класів, що використовують карту пам'яті в своєму функціоналі.

Нижче перераховано його основні переваги в порівннянні з бібліотекою SD.

* Методи запису і читання файлів виконують операції значно швидше.
* Реалізує методи для швидкого сканування вмісту каталогу на карті пам'яті, в тому числі з фільтрацією по розширенню файла.
* Автоматично використовує PSRAM, якщо доступна.
* Усі операції є потокобезпечними.
* Копіювання та видалення виконуються в іншій задачі, завдяки чому GUI не блокується.
* Підтримує видалення не порожніх каталогів.

::: {warning}
Не використовуйте будь-які інші способи взаємодії з картою пам'яті чи файлами на ній під час використання Pixeler, окрім як через вбудований файловий менеджер.
Замість стандартного FileStream, що доступний в Arduino, за потреби використовуйте клас з файлу `pixeler/src/util/file/FileStream.h`.
Інакше поведінка коду буде невизначеною.
:::

Файловий менеджер доступний глобально в будь-якому класі контексту через об'єкт `_fs`.

::: {note}
Методи файлового менеджера, які відсутні в даному розділі докментації, не потребують додаткових пояснень. 
З їх описом можна ознайомитись самостійно у файлі `pixeler/src/manager/FileManager.h` або через виклик підказки в IDE.
::: 
<br>
<br>

## Налаштування

Усі налаштування карти пам'яті та її шини SPI знаходяться в файлі `pixeler/setup/sd_setup.h`.
В ньому потрібно вказати номер пристрою шини SPI, що буде використовуватись для обміну даними з картою пам'яті, номери пінів, до яких підключена шина, її частоту тощо.

::: {note}
На різних моделях ESP номери пристроїв SPI можуть відрізнітися. Тому необхідно уточнювати інформацію в документації під конкретний МК.
::: 
<br>
<br>

## Монтування

Перш ніж виконувати будь-які операції з файлами на карті пам'яті, після запуску пристрою її необхідно примонтувати та перевірити результат монтування.


```cpp
if (_fs.mount())
{
  // Обробка успішного монтування
}
else
{
  // Обробка помилки монтування
}
```

Після завершення роботи з файлами, карту пам'яті бажано відмонтувати перед вимкненням пристрою.

```cpp
_fs.unmount();
```

::: {danger}
До виклику демонтування карти пам'яті або перед вимкненням пристрою, обов'язково потрібно закрити всі відкриті файли на ній. 
В іншому випадку дані на карті пам'яті можуть бути пошкоджені.
:::
<br>
<br>

## Шлях до файлів

Шлях до файлів для файлового менеджера необхідно вказувати завжди без точки монтування. Її буде додано автоматично.
Наприклад, для читання кореневого каталогу потрібно відкрити файл за шляхом `/`. Або `/some_file.txt` для роботи з файлом, що лежить в корені карти пам'яті і тд.
<br>
<br>

## Відкрити файл

Для тривалої роботи з одним і тим же файлом, наприклад, надсилання великого файлу по мережі, потрібно отримати вказівник на нього.

```cpp
  /**
   * @brief Повертає вказівник на бінарний файл, який було відкрито у вказаному режимі.
   *
   * @param path Шлях до бінарного файла, вказаний без точки монтування.
   * @param mode Режим відкриття бінарного файла.
   * @return FILE* - вказівник на відкритий бінарний файл. 
   * @return NULL - якщо операція завершилася невдачею.
   */
  FILE* openFile(const char* path, const char* mode);
```

У мові C існують наступні режими відкриття файлу:

`Базові режими`

* `r`	*Читання* -	Повертає NULL, якщо файл не знайдено.
* `w`	*Запис*	- Створює новий файл або повністю перезаписує існуючий.
* `a`	*Дозапис* - (Append) Створює файл або додає дані в кінець існуючого.
<br>

`Розширені режими`

* `r+` Відкриває для читання та запису. Курсор на початку. Файл мусить існувати.
* `w+` Відкриває для читання та запису. Якщо файл існує - видаляє вміст, якщо ні - створює новий.
* `a+` Відкриває для читання та дозапису. Читання можливе з будь-якого місця, але будь-який запис завжди переносить курсор у кінець файлу.
<br>
<br>

Після завершення роботи з файлом, його обов'язково потрібно самостійно закрити.

```cpp
  /**
   * @brief Закриває відкритий бінарний файл.
   *
   * @param file Посилання на вказівник на відкритий бінарний файл.
   */
  void closeFile(FILE*& file);
```

Якщо цього не зробити, дані в файлі можуть пошкодитися за певних умов.
<br>
<br>

## Прочитати з файлу

Для ефективного читання з файлу, файловий менеджер Pixeler пропонує на вибір три варіанти зчитування даних з нього.
<br>

У випадку, якщо потрібно одноразово прочитати файл повністю або частково, використовуйте метод, 
який не потребує ручного відкриття та закриття файлу.

```cpp
/**
 * @brief Читає бінарний файл за вказаним шляхом.
 *
 * @param path Шлях до бінарного файла, вказаний без точки монтування.
 * @param out_buffer Вихідний буфер, куди будуть записані прочитані байти.
 * @param len Кількість байтів, які повинні бути прочитані.
 * @param seek_pos Позиція від початку бінарного файла у байтах, 
 * з якої необхідно розпочати читання.
 * @return size_t - кількість успішно прочитаних байтів. 
 * @return 0 - Якщо операція завершилася невдачею за будь-якої причини.
 */
size_t readFile(const char* path, void* out_buffer, size_t len = 1, int32_t seek_pos = 0);
```
<br>
Наступні методи потрібно використовувати у випадку, якщо файл оброблюється частинами. 
Для їх використання спершу потрібно відкрити файл в режимі читання.

```cpp
/**
 * @brief Читає вказану кількість байтів з відкритого бінарного файла.
 *
 * @param file Вказівник на відкритий бінарний файл.
 * @param out_buffer Вихідний буфер, куди будуть записані прочитані байти.
 * @param len Кількість байтів, які повинні бути прочитані.
 * @param seek_pos Позиція від початку бінарного файла у байтах, з якої необхідно розпочати читання.
 * @return size_t - Кількість успішно прочитаних байтів.
 */
size_t readFromFile(FILE* file, void* out_buffer, size_t len = 1, size_t seek_pos = 0);

/**
 * @brief Читає вказану кількість байтів з відкритого бінарного файла.
 *
 * @param file Вказівник на відкритий бінарний файл.
 * @param out_buffer Вихідний буфер, куди будуть записані прочитані байти.
 * @param len Кількість байтів, які повинні бути прочитані.
 * @param seek_pos Позиція від початку бінарного файла у байтах, з якої необхідно розпочати читання.
 * Якщо 0 - читає з поточної.
 * @return true - якщо операція виконана успішно.
 * @return false - якщо операція завершилася невдачею.
 */
bool readFromFileExact(FILE* file, void* out_buffer, size_t len = 1, size_t seek_pos = 0);
```
<br>
Різниця між цими двома методами полягає лише в результаті, що повертається. 

Тому, якщо обов'язково потрібно прочитати вказану кількість байтів з файлу, краще викликати `readFromFileExact`. Якщо допускається читання будь-якої кількості даних з файлу, в такому випадку кращим варіантом буде `readFromFile`, який повертає кількість прочитаних байтів.
<br>
<br>

## Записати в файл

Аналогічно до методів читання потрібно використовувати методи для запису даних в файл.

```cpp
/**
 * @brief Створює або перезаписує бінарний файл, 
 * та записує до нього вказану кількість байтів із буфера.
 * Байти записуються блоками, якщо це можливо, для більш швидкого виконання операції.
 *
 * @param path Шлях до бінарного файла, вказаний без точки монтування.
 * @param buffer Буфер, з якого байти будуть записані до бінарного файлу.
 * @param len Кількість байтів, які повинні бути записані до файлу.
 * @return size_t - кількість успішно записаних байтів. 
 * @return 0 - якщо операція завершилася невдачею.
 */
size_t writeFile(const char* path, const void* buffer, size_t len);

/**
 * @brief Записує вказану кількість байтів до відкритого бінарного файлу.
 * Байти записуються блоками, якщо це можливо, для більш швидкого виконання операції.
 *
 * @param file Вказівник на відкритий бінарний файл.
 * @param buffer Буфер, з якого байти будуть записані до бінарного файлу.
 * @param len Кількість байтів, які повинні бути записані до файлу.
 * @return size_t - кількість успішно записаних байтів. 
 * @return 0 - якщо операція завершилася невдачею.
 */
size_t writeToFile(FILE* file, const void* buffer, size_t len);
```

Ці методи автоматично викликають скидання WD-таймера, якщо операція запису великого буферу займає багато часу.

::: {warning}
Скидання WD-таймера не буде викликано, якщо виклик методу відбувається в циклі з передачею малих порцій даних.
Очікується, що в такому випадку користувач самостійно буде контролювати стан задачі.
::: 
<br>
<br>

## Видалення файлів та каталогів

Файловий менеджер реалізує три варіанти видалення файлів.

1. Видалення бінарного файлу в контексті поточної задачі.

```cpp
/**
 * @brief Видаляє бінарний файл в контексті поточної задачі.
 *
 * @param path Шлях до файла, вказаний без точки монтування .
 * @return true - якщо операція виконана успішно.
 * @return false - якщо операція завершилася невдачею.
 */
bool rmFile(const char* path);
```

2. Видалення каталогу в контексті поточної задачі.

```cpp
/**
 * @brief Видаляє папку в контексті поточної задачі.
 *
 * @param path Шлях до папки, вказаний без точки монтування.
 * @return true - якщо операція виконана успішно.
 * @return false - якщо операція завершилася невдачею.
 */
bool rmDir(const char* path);
```

3. Видалення в новій задачі на іншому ядрі МК.

```cpp
/**
 * @brief Намагається створити та запустити задачу FreeRTOS, 
 * в процесі роботи якої, буде виконана спроба
 * видалити бінарний файл або папку за вказаним шляхом.
 *
 * @param path Шлях до ВказівникаНаФайл, вказаний без точки монтування.
 * @return true - якщо задачу було успішно створено та запущено.
 * @return false - якщо вже працює будь-яка інша задача файлового менеджера 
 * або не вдалося створити нову задачу за будь-якої причини.
 */
bool startRemoving(const char* path);
```
<br>
<br>

::: {warning}
Повернення `true` з виклику `startRemoving` не означає загальний успіх операції. 
Це лише означає, що задача видалення була успішно запущена.
::: 
<br>

Приклад використання:

```cpp
bool result = false;
if (_fs.startRemoving(path))
{
  while (_fs.isWorking())
    delay(2);

  result = _fs.lastTaskResult();
}
else
{
  // Невдача запуску задачі
}
```

Даний приклад не має значного сенсу, так само як і виклик видалення в новій задачі, 
якщо в прошивці не реалізовано скасування операції або оновлення прогресу операції.
<br>
<br>
Задачу видалення можна зупинити. 
Вона буде зупинена після видалення файлу, який вже знаходиться в процесі видалення.
Видалені файли та каталоги не можуть бути відновлені, навіть, у разі скасування задачі.
<br>
<br>
Виклик видалення каталогу рекурсивно видалить увесь його вміст. 
Якщо глибина вкладеності каталогів неадекватно велика, то може трапитися збій прошивки через переповнення стеку викликів.

::: {note}
Одночасно може працювати лише одна паралельна задача файлового менеджера.
Спроба запуску додаткової задачі, якщо вже працює інша фонова задача файлового менеджера, завершиться невдачею. 
:::
<br>
<br>

## Копіювання файлів

Копіювання файлів доступне тільки в контексті нової задачі. 
Копіювання каталогів наразі не підтримується.
<br>
<br>

```cpp
/**
 * @brief Намагається створити та запустити задачу FreeRTOS, 
 * в процесі роботи якої буде виконана спроба створити копію вказаного бінарного файлу.
 *
 * @param from Шлях до вказівника на бінарний файл, вказаний без точки монтування, 
 * з якого буде виконана спроба створити копію.
 * @param to Шлях до бінарного файла, вказаний без точки монтування, 
 * куди буде виконана спроба створити копію.
 * @return true - якщо задачу було успішно створено та запущено.
 * @return false - якщо вже працює будь-яка інша задача файлового менеджера 
 * або не вдалося створити нову задачу за будь-якої причини.
 */
bool startCopyFile(const char* from, const char* to);
```
<br>
<br>

::: {warning}
Повернення `true` з виклику `startCopyFile` не означає загальний успіх операції. 
Це лише означає, що задача копіювання була успішно запущена.
::: 
<br>

Приклад використання:

```cpp
bool result = false;
if (_fs.startCopyFile(path_from, paath_to))
{
  while (_fs.isWorking())
  {
    log_i("Progress: %u%", _fs.getCopyProgress());
    delay(1);
  }

  result = _fs.lastTaskResult();
}
else
{
  // Невдача запуску задачі
}
```
<br>
<br>
Задача копіювання файлу може бути скасована.
Якщо задачу скасовано, неповну копію файлу буде автоматично видалено.

::: {note}
Одночасно може працювати лише одна паралельна задача файлового менеджера.
Спроба запуску додаткової задачі, якщо вже працює інша фонова задача файлового менеджера, завершиться невдачею. 
:::
<br>
<br>

## Переіменування та переміщення

Перейменування та переміщення це одна і та ж операція, яка може бути застосована однаково як до файла так і до каталога. 

```cpp
/**
 * @brief Перейменовує ВказівникНаФайл.
 *
 * @param old_name Старий шлях до ВказівникНаФайл, вказаний без точки монтування.
 * @param new_name Новий шлях до ВказівникНаФайл, вказаний без точки монтування.
 * @return true - якщо операція виконана успішно.
 * @return false - якщо операція завершилася невдачею.
 */
bool rename(const char* old_name, const char* new_name);
```
<br>
<br>

## Потокобезпечність

Усі операції файлового менеджера є повністю потокобезпечними. 
Тобто їх можна викликати одначасно з різних задач на різних ядрах МК.
