# Контекст

В складній прошивці зі значною кількістю коду виникають труднощі, коли доводиться цей код підтримувати або додавати новий функціонал.
Особливо, якщо це відбувається в одному або декількох сильнозв'язаних файлах.
Інша проблема, яка йде поряд з попередньою, виникає коли в коді використовується багато глобальних змінних.
Кожна з них оголошується один раз та назавжди займає місце в оперативній пам'яті МК, навіть, якщо вона ніяк не задіяна в поточний момент часу.
<br>
<br>
В Pixeler ця задача вирішується шляхом розбиття прошивки на класи `контексту`.
Контекст це ізольоване середовище в якому виконується користувацький код. 
<br>
<br>
Для того, щоб легше зрозуміти це поняття, найкраще уявляти контекст у вигляді коробки.
Коробка має роз'єм до якого можна підключитися щоб передати деяку інформацію всередину коробки. Коробка, в свою чергу, може, якщо їй це буде потрібно, взаємодіяти із зовнішнім світом через цей роз'єм, керувати механізмами, тощо. Або повернути деяку інформацію, наприклад, про завершення роботи в цій коробці. Ніхто не знає, що відбувається всередині, крім того, хто запрограмував цю коробку. Через те, що коробка фізично ізольована від зовнішнього світу, ніхто не може випадково втрутитися в магію, що відбувається в ній, а магія не нашкодить нікому, хто випадково засунув руки, куди не варто було втручатися.
<br>
<br>
Всю систему Pixeler спрощено можна уявити наступним чином. Посеред кімнати стоїть стіл з роз'ємом, до якого можна підключити лише одну коробку контексту. Біля столу стоїть один автоматизований маніпулятор. Перед початком роботи в кімнату доставляється шафа з пронумерованими коробками. Ці коробки створює та наповнює розробник. Маніпулятор, завдяки налаштуванням Pixeler, знає яку коробку необхідно підключити першою до роз'єму, що він і робить. Після підключення, коробка починає виконувати свою задачу. Через роз'єм, отримує інформацію про стан кнопок, датчиків, керує пінами мікроконотролера, виводить зображення на дисплей і тд. Коли задача цієї коробки виконана, через роз'єм подається команда, що поточну коробку потрібно замінити, та номер коробки, яка повинна бути підключена наступною. Маніпулятор зчитує ці дані, відключає поточну коробку, та приєднує наступну за вказаним номером. Після цього увесь процес повторюється.
<br>
<br>
Тепер, якщо замінити в уяві кімнату на чіп ESP, шафу з коробками - налаштуваннями Pixeler та класами контексту, маніпулятор - кодом Pixeler, то отримаємо майже повну модель системи. В якій роз'ємом для обміну даними та командами є стандартні бібліотеки ESP-IDF, Arduino, та спеціальні бібліотеки, які написані для Pixeler. Залишилося тільки додати той факт, що в коробці може бути реалізовано свій міні-маніпулятор і свій набір вкладених коробок. І так далі, поки не закінчиться пам'ять для стеку викликів;)
<br>
<br>
Якщо приклад з коробками був недостатньо наочним, тоді найпростіше кожен окремий клас контексту уявляти, як окремий файл `main.cpp` в Arduino. В ньому також є аналог `setup`, `loop`, та додається `update`. При цьому вже по замовченню доступно багато можливостей для взаємодії з МК та периферією, а також автоматизовано перемикання цих файлів, в залежності від поточної задачі прошивки. 
<br>
<br>
Розглянемо мінімальний приклад контексту. Маємо ESP з підключеним дисплеєм та кнопками. Після завантаження Pixeler знаходимося в контексті(коробці) головного меню.
<br>
<br>
Замість `setup` використовуємо конструктор класа контексту.

```cpp
MenuContext::MenuContext()
{
  // Створюємо з допомогою шаблонізатора новий порожній макет,
  // який буде каркасом для GUI
  EmptyLayout* layout = WidgetCreator::getEmptyLayout();

  // Встановлюємо цей макет для поточного контексту
  setLayout(layout);

  // Створюємо віджет меню з унікальним ідентифікатором,
  // по якому зможемо його знайти, за потреби, на макеті
  FixedMenu *menu = new FixedMenu(ID_MENU);

  // Додаємо цей віджет до раніше створеного макету
  layout->addWidget(menu);

  // Створюємо новий пункт меню з унікальним ідентифікатором
  MenuItem* files_item = WidgetCreator::getMenuItem(ID_CONTEXT_FILES);

  // Додаємо створений пункт до меню
  menu->addItem(files_item);

  // Отримуємо налаштування з карти пам'яті та застосовуємо їх, 
  // встановлюємо початковий стан пінів тощо
  // ...
}
```
<br>
<br>

В методі `update`, який викликається автоматично кожен кадр, оброблюємо натискання кнопок.

```cpp
void MenuContext::update()
{
  // Оброблюємо стан кнопок
  if (_input.isHolded(BtnID::BTN_UP))
  {
    // Блокуємо кнопку для уникнення помилкового спрацювання
    // на HOLD_LOCK мс
    _input.lock(BtnID::BTN_UP, HOLD_LOCK);
    up();
  }
  else if (_input.isReleased(BtnID::BTN_BACK))
  {
    _input.lock(BtnID::BTN_BACK, CLICK_LOCK);
    // Якщо натиснута відповідна кнопка, віддаємо команду Pixeler,
    // для звільнення поточного контексту, та завантаження нового
    // з ідентифікатором ID_CONTEXT_HOME
    openContextByID(ID_CONTEXT_HOME);
  }
  // Далі оброблюємо натискання інших кнопок
  //...
}

void MenuContext::up()
{
  // Переміщуємо фокус на попередній елемент меню
  _menu->focusUp();
}

void MenuContext::down()
{
  // Переміщуємо фокус на наступний елемент меню
  _menu->focusDown();
}
```
<br>
<br>

В методі `loop`, який викликаєть автоматично, виконуємо будь-який вископродуктивний код.
Так само, як в loop з main.cpp, Arduino фреймворку.

```cpp
bool MenuContext::loop()
{
  // Тут виконується робота, 
  // яка не повинна перериватися довгими затримками.
  // Наприклад, відтворення музики.
  // ...

  return true;
}
```
Метод loop повертає булеве значення. 
Воно вказує Pixeler, а точніше батьківському `IContext`, чи повинен він зчитувати стан вводу в тому контексті, де викликається цей loop. 
True повинен повертати лише активний та найбільш глибоко вкладений контекст.
Це необхідно для уникнення багаторазового зчитування стану вводу для кожного вкладеного контексту в межах одного кадру.
Окрім того, контекст, який повернув false зі свого loop-методу, не бере участі в формування зображення для дисплею,
якщо GUI використовується в прошивці. 
Тобто у нього взагалі не буде викликано метод update. Завдяки цьому майже увесь процесорний час отримає саме активний контекст. 
<br>
<br>
Кожен клас контексту повинен реалізувати конструктор з ініціалізацією.
Деструктор, в якому може не бути коду.
А також loop та update.
Вся інша логіка та методи додаються на розсуд розробника.

## Життєвий цикл

Для глибшого розуміння функціонування контексту, варто знати етапи його життєвого циклу.
<br>
<br>
Після створення Pixeler-ом об'єкту контексту, в нескінченному циклі відбувається виклик його методу `tick`.
Цей метод реалізовано в абстрактному класі IContext, та не потребує додаткової реалізації.
Саме в ньому відбувається виклик loop через таблицю віртуальних методів.
Якщо loop повернув false, для цього контексту життєвий цикл завершується до наступного виклику його tick-методу.
Якщо loop повернув true, відбуваєтсья перевірка, щоб метод update викликався не частіше, ніж це вказано в налаштуваннях Pixeler.
Якщо метод update може бути викликаний, відбувається зчитування стану користувацького вводу.
Після цього викликається метод update в користувацькому класі контексту.
<br>
Очікується, що в методі update відбувається основна обробка логіки кадру.
Та, якщо підключено GUI частину Pixeler, формування забораження для дисплею.
Створення Toast тощо.
<br>
Після виклику update, якщо активовано GUI, відбувається передача сформованого зображення задачі,
яка виводить його на дисплей на іншому ядрі, не блокуючи поточне.

## Перемикання контексту

Якщо контекст знаходиться на першому рівні вкладеності, його перемиканням займається Pixeler.
<br>
Коли цей контекст завершує свою роботу та повинен бути звільнений, достатньо викликати метод,
який реалізовано в IContext:

```cpp
openContextByID(CONTEXT_ID);
```
Де **CONTEXT_ID** це унікальний ідентифікатор для глобально зараєстрованого контексту.
<br>
Перш ніж викликати tick поточного контексту, Pixeler перевірить, чи не повинен той бути звільненим, та запитає ідентифікатор контексту, 
який потрібно завантажити наступним.
Після цього поточний контекст буде звільненй, замість нього завантажиться наступний, та вже до нового буде застовуватися механізм,
що описано в попредньому розділі.

## Реалізація маніпулятора контекстами

Часто буває, коли логічно деякий код має відношення до одного контексту.
Наприклад, налаштування системи. Але фактично це код, який ніяк не пов'язаний між собою. 
Для прикладу, налаштування годинника не має ніякого відношенн до налаштувань модуля WiFi.
<br>
Або інший випадок, в контексті гри ми не хочемо втрачати деякі глобальні дані. 
Наприклад, про стан персонажа.
При цьому, необхідно змінювати ігрові сцени, які ніяк не пов'язані одна з одною.
<br>
В такому випадку потрібно самостійно реалізувати маніпулятор для зміни контекстів.
<br>
<br>
Найкращим рішенням буде його реалізація в методі loop глобального контексту.
Тобто того, який зареєстровано глобально в прошивці через налаштування.
Ось як це реалізовано для контексту налаштувань в одній із прошивок на Pixeler:

```cpp
bool PrefSelectContext::loop()
{
  // Якщо поточний контекст знаходиться в режимі маніпулятора субконтекстами
  if (_mode == MODE_SUBCONTEXT)
  {
    // Якщо поточний субконтекст не потребує звільнення
    if (!_sub_context->isReleased())
    {
      // Викликаємо його метод tick
      _sub_context->tick();
      // Та завершуємо свій цикл
      return false;
    }
    else
    {
      // Якщо поточний субконтекст повинен бути звільненим,
      // видаляємо його.
      delete _sub_context;
      _sub_context = nullptr;
      // Змінюємо режим роботи основного контексту
      _mode = MODE_NORMAL;
      // Завантажуємо макет для відображення на дисплей
      showMainTmpl();
      // Повертаємо true, що означатиме, що поточний контекст буде малювати на дисплей в наступному кадрі,
      // а також займатиметься обробкою вводу.
    }
  }

  // Якщо поточний контекст є основним
  return true;
}
```

Субконтексти не потрібно реєструвати глобально. Також, в даному випадку, їм не потрібно мати власний ідентифікатор. 
Тому що вони всі завершуютсья поверненням в основний контекст налаштувань.
Проте для перемикання ігрових рівнів може знадобитися також додавання локальної, для гри, системи ідентифікаторів рівнів.
<br>
<br>
Якщо поточний контекст не є глобальним і не повинен перемикати контексти, тоді для його завершення достатньо викликати метод `release`

```cpp
if (_input.isReleased(BtnID::BTN_BACK))
{
  _input.lock(BtnID::BTN_BACK, CLICK_LOCK);
  release();
}
```
Цей метод встановить прапор, який буде вказувати маніпулятору контекстів на необхідність звільнення поточного,
проте не вказуватиме ідентифікатор наступного контексту.

## Реєстрація контексту

Для того, щоб Pixeler автоматично перемикав контексти, їх необхідно зареєструвати глобально.
Реєстрація глобального контексту відбувається в файлах налаштувань, 
що повинні знаходитись за шляхом `pixeler_setup/context_id_setup.h` та `pixeler_setup/ui_setup.h`.
<br>
<br>
У файлі `context_id_setup.h` в перечислення типу `ContextID` додаються ідентифікатори контексту.
Саме вони використовуються в якості ключа для завантаження наступного контексту.
<br>
<br>
У файлі `ui_setup.h` потрібно вказати два налаштування. 
<br>
Перше - для макросу `START_CONTEXT` обов'язково вказати
ім'я типу глобального контексту, який буде буде завантажуватися першим, після ініціалізації Pixeler.

```cpp
  #define START_CONTEXT SplashContext
```
Після цього, до unordered_map за прикладом, потрібно додати фабрику, яка буде створювати об'єкт конкретного контексту
по його ідентифікатору.

```cpp
  std::unordered_map<ContextID, std::function<IContext*()>> _context_id_map = {

      {ContextID::ID_CONTEXT_SPLASH, []()
       { return new SplashContext(); }},

      {ContextID::ID_CONTEXT_HOME, []()
       { return new HomeContext(); }},
  };
```

В цій мапі ключем є унікальний глобальний ідентифікатор контексту, який було додано раніше до перечислення у файлі `context_id_setup.h`.
А значенням - функція, яка створює об'єкт відповідного контексту та повертає вказівник на нього.
