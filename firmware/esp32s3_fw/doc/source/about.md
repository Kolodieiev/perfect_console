# Про проєкт

Pixeler це компроміс між зручним для використання, швидким та надійним кодом. Проте на першому місці все ж таки стоять зручність та швидкодія.

Для кращого розуміння, принципів функціонування фреймоврку варто ознайомитися з наступними підходами до його розробки:
* Ми дуже не любимо послідовності викликів C-шних функцій, тому загортаємо все в зручні класи.
Окрім коду де потрібна максимальна продуктивність. В таких випадках можна й регістр читати.
* Замість копіювання даних або об'єктів, ми користуємося сирими вказівниками та посиланнями, окрім випадків коли потрібна саме копія.
* Ми завжди хочемо перевикористовувати великі масиви даних, такі як зображення. Тому об'єкт не видаляє дані за отриманим вказівником, якщо ці дані потенційно займають багато місця в пам'яті та можуть бути перевикористані іншим об'єктом.
* В той же час ми не хочемо кешувати вказівники на всі створені невеликі об'єкти. Тому якщо об'єкт, що приймає вказівник, є контейнером для цих вказівників, він повинен самостійно викликати видалення за цими вказівниками, навіть, якщо не він їх створював.
* Ми не бачимо нічого поганого в тому, щоб отримувати доступ до "популярного" об'єкта по закешованому вказівнику, навіть, якщо цей об'єкт видаляється в іншому місці. Але лише за умови, що використовується машина станів, яка гарантовано унеможливить звертання до висячого вказівника.
* Виклик віртуальних методів кращий за шаблони.
* Якщо отримали помилку або неочікуване значення в коді, викликаємо перевантаження прошивки, аби розробник звернув увагу на цю проблему під час тестування.
Але це не стосується обробки зовнішніх вхідних даних.
* За бажання, необережними програмуванням можна зламати майже будь-яку систему. 
Тому перевіряємо тільки зовнішні вхідні дані, вказівники на nullptr та значення, які програміст вводить дуже часто через що може випадково помилитися.
В інших випадках очікуємо, що дані валідні, аби не роздувати прошивку перевірками заради перевірок. Тому якщо, наприклад, метод повинен отримувати ціле число в позитивному діапазоні, параметр методу краще оголосити беззнаковим, а відповідальність за вхідне значення перекласти на розробника, аніж додавати перевірку знака, яка можливо ніколи і не знадобиться.

Не дивлячись на те, що майже всі ці підходи порушують загальноприйняті принципи класичного програмування, їх було обрано з певних, цілком об'єктвиних для програмування мікроконтролерів, причин.<br>
Ви можете лише прийняти їх або відмовитися від використання Pixeler, якщо вважаєте такий підхід до програмування недостатньо надійним для вашої задачі.

Розробка проєкту виконується на ОС Linux та періодично тестується на Windows, тому деякі інструменти збірки можуть бути налаштовані некоректно на інших системах окрім Linux в певний момент.<br>
Для тестування прошивки використовується мікроконтролер ESP32S3, на ESP32 та ESP32P4 код тестується періодично, 
тому деякий функціонал може працювати некоректно в певний момент. Або може працювати дещо інакше, через внутрішні відмінності цих мікроконтролерів.

## Про документацію

Ця документація створена з метою навчити створювати прошивки для ESP на Pixeler будь-кого, в тому числі новачків.
Вона не містить повного переліку та опису усіх методів в класах. З ним користувач повинен самостійно ознайомитись у відповідних файлах.
Усі неочевидні моменти архітектури Pixeler, будуть описані в ній. Проте користувач повинен самостійно розібратися з усіма, незрозумілими для нього, речами в мовах C++/Lua за допомогою ШІ або пошукових систем.

## Скорочення та визначення

МК - Мікроконтролер.<br>
ESP - Мікроконтролер серії ESP32/ESP32S3/ESP32P4.
GUI - Графічний інтерфейс користувача.

## Правила іменування

В Pixeler використовуються наступні правила іменування.

* Префікс `I` в імені типу означає, що клас є абстрактним. Наприклад, `IWidget`.
* Префікс `__`(два нижніх підкреслення) в імені методу означає, що метод не рекомендується або заборонено до виклику користувачем. Наприклад, `void __tick();`
* Префікс `_`(одне нижнє підкреслення) в імені об'єкта означає, що він є глобальним. Наприклад, `_fs`.
* Усі букви в верхньому регістрі означають ім'я визначення або константного значення. Наприклад, `SOME_NAME`.
* Для іменування типів використовується `UpperCamelCase`.
* Для іменування методів використовується `lowerCamelCase`.
* Для іменування об'єктів використовується `snake_case`.

## Повідомити про помилку

<a href="https://github.com/Kolodieiev/perfect_console/issues/new" target="_blank">Створити issue на Github</a>